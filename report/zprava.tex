\documentclass[12pt]{article}
\usepackage{epsf,epic,eepic,eepicemu}
%\documentstyle[epsf,epic,eepic,eepicemu]{article}
\usepackage[cp1250]{inputenc}
\usepackage{graphicx}
\begin{document}
%\oddsidemargin=-5mm \evensidemargin=-5mm \marginparwidth=.08in
%\marginparsep=.01in \marginparpush=5pt \topmargin=-15mm
%\headheight=12pt \headsep=25pt \footheight=12pt \footskip=30pt
%\textheight=25cm \textwidth=17cm \columnsep=2mm \columnseprule=1pt
%\parindent=15pt\parskip=2pt

\begin{center}
\bf Semestrální projekt MI-PAR 2011/2012:\\[5mm]
    Paralelní algoritmus pro øešení problému\\[5mm]
       Tomáš Èerevka\\
       Adam Èinèura\\[2mm]
magisterské studium, FIT ÈVUT, Kolejní 550/2, 160 00 Praha 6\\[2mm]
\today
\end{center}

\section{Definice problému}
Úloha ZHV: Zobecnìné Hanojské Vìe

\subsection{Vstupní data}
n = pøirozené èíslo pøedstavující celkovı poèet etonù,$n \geq 16$ . 

eton $i, i=1,...,n,$  má prùmìr \textit{i}.

s = pøirozené èíslo pøedstavující poèet tyèek,$n \div 4 \geq s > 3$ 

r = èíslo cílové tyèky,$1 \leq r \leq s$ 

$V[1,..,s] =$ mnoina neúplnıch hanojskıch vìí.

\subsection{Definice}
Hanojská vì o vıšce \textit{k} je vì \textit{k} rùznıch etonù, které jsou uspoøádány od nejmenšího k nejvìtšímu a rozdíly ve velikostech sousedních etonù jsou vdy 1. Neúplná hanojská vì o vıšce \textit{k} je vì \textit{k} rùznıch etonù, které jsou uspoøádány od nejmenších k nejvìtším a rozdíly ve velikostech alespoò 1 dvojice sousedních etonù je alespoò 2.

Napøíklad pro k=5 je to neúplná vì 2,3,7,8,10.

\subsection{Generování poèáteèního stavu}
V poøadí prùmìrù etonù $n,n-1,..,1$ se etony náhodnì rozhazují na \textit{s} tyèek, take vznikne \textit{s} obecnì neúplnıch hanojskıch vìí. 

\subsection{Pravidla}
Jeden tah je pøesun etonu z vrcholu jedné vìe na jedné tyèce na jinou prázdnou tyèku nebo na vrchol vìe zaèínající etonem s vìtším prùmìrem. 

\subsection{Úkol}
Na zadané tyèce \textit{r} postavte úplnou hanojskou vì o vıšce \textit{n} pomoci minimálního poètu tahù. 
 
\subsection{Vıstup algoritmu} 
Vıpis poètu tahù a jejich posloupností v následujícím formátu: eton, pùvodní tyèka $\rightarrow$ cílová tyèka.  

\subsection{Sekvenèní algoritmus} 
Øešení musí existovat. Sekvenèní algoritmus je typu BB-DFS s neomezenou hloubkou prohledávání (obecnì se mohou pro $s > 3$ pøi prohledávání generovat cykly). Hloubku prohledávání musíme omezit horní mez (viz dále). Ve stavu, kdy nelze pøesunout ádnı eton, se provede návrat. Cena, kterou minimalizujeme, je poèet tahù. Algoritmus konèí, kdy je poèet tahù roven dolní mezi, jinak prohledává celı stavovı prostor do hloubky dané horní mezí. 

Tìsnou dolní mez poètu tahù lze urèit takto: je-li eton na cílové tyèce, ale není na správné pozici, pak musí provést aspoò 2 tahy. Je-li eton na jiné ne cílové tyèce, pak musí provést aspoò 1 tah. Dolní mez je souèet tìchto minimálních poètù tahù pro všechny etony. Tato dolní mez je dosaitelná pro dostateènì velká \textit{s}. 

\section{Popis sekvenèního algoritmu}
Program pro sekvenèní algoritmus je napsán objektovım pøístupem. Hrací deska, vì, tah tokenem a objekt ukládanı na zásobník jsou reprezentovány kadı svou tøídou. Veškerı vıkonovı kód algoritmu je obsaen ve tøídì Solver. Implementaci vlastního zásobníku jsem neprovádìli, pouili jsme standardní implementaci z knihovny STL.

Algoritmus zaèíná naètením vstupních dat, pøipravením vıchozího stavu a jeho uloením na zásobník. Poté algoritmus prohledává stavovı prostor a do hloubky horní meze specifikované v zadání. Pokud algoritmus nalezne øešení, zmenší hloubku prohledávaného prostoru na hloubku nalezeného øešení - ve vìtší hloubce není moné nalézt lepší øešení. V pøípadì, kdy algoritmus nalezne další øešení, lepší (v menší hloubce) ne pùvodní øešení, zmenší opìt hloubku prohledávání na hloubku lepšího øešení.

Pøi provádìní expanze zásobníku algoritmus kontroluje zda by provedením tahu nevznikl cyklus délky 1 (tah tokenem tam a zpátky). Pokud cyklus vznikl, pak pøíslušnı stav není na zásobník uloen. Dále je pøi expanzi zásobníku kontrolováno zda novı stav mùe vést k øešení pomocí tìsné dolní meze. Pokud nemùe vést k øešení, také není na zásobník uloen. Bìh algoritmu je pøedèasnì ukonèen pokud je nalezeno øešení v hloubce rovné dolní mezi.

Algoritmus naèítá zadání ze souboru. Název souboru je programu specifikován jako parametr pøíkazové øádky -f. Pøíklad spuštìní programu, kdy je zadání specifikováno v souboru input1.txt, je následující:\begin{center}

compiledFile -f/path/to/input1.txt 
\end{center} 
Formát vstupního souboru je následující:
\begin{flushleft}
4 0 22

8 2

6 5

4 3

7 1
\end{flushleft}
Vıznam souboru je následující: 4 vìe, cílová vì je 0. v poøadí, maximální hloubka prohledávání je 22, následují øádky pro jednotlivé vìe, kadá vì je specifikována hodnotami svıch tokenù v sestupném poøadí dle velikosti.

Vıstupem algoritmu je posloupnost tahù, které postaví na poadované pozici kompletní hanojskou vì ve formátu:
\begin{flushleft}
$[2, 0 \rightarrow 2]$

$[1, 3 \rightarrow 2]$

$[7, 3 \rightarrow 0]$

$[5, 1 \rightarrow 3]$

$[1, 2 \rightarrow 3]$

$[6, 1 \rightarrow 0]$

$[2, 2 \rightarrow 1]$

$[1, 3 \rightarrow 1]$

$[5, 3 \rightarrow 0]$

$[3, 2 \rightarrow 3]$

$[4, 2 \rightarrow 0]$

$[3, 3 \rightarrow 0]$

$[1, 1 \rightarrow 3]$

$[2, 1 \rightarrow 0]$

$[1, 3 \rightarrow 0]$

Solution depth: 15
\end{flushleft}

První èíslo udává hodnotu tokenu, kterım je tah provádìn. Zbylá dvì èísla udávají index vìe, z které byl token odebrán(pøed šipkou) a index vìe, na kterou je token umístìn(za šipkou). Zde je naše jediná odchylka od zadání - èíslujeme vìe od 0 namísto od jednièky. Stejné èíslování pouíváme i pøi naèítání dat.
\subsection{Doba bìhu sekvenèního algoritmu}
 
 \begin{table}[!h]
 \begin{center}
    \begin{tabular}{ | l | l |}    
    \hline
    Prohledávaná hloubka & Doba bìhu[s]  \\ \hline
    18 & 48  \\ \hline
    19 & 70 \\ \hline
    20 & 146 \\ \hline
    21 & 429  \\ \hline
    22 & 649 \\ \hline
    \end{tabular}
     \caption{Doba bìhu pøi úplném prohledání stavového prostoru}
    \end{center}
     \end{table}

\section{Popis paralelního algoritmu a jeho implementace v MPI}
Paralelní algoritmus je typu L-PBB-DFS-D, vznikl paralelizací sekvenèního algoritmu, proto jsou metody pro expanzi zásobníku a vyhodnocení stavu na vrcholu zásobníku stejné. Podstatnou zmìnou oproti sekvenènímu øešení je nahrazení zásobníku vektorem - také standardní implementace z STL. Toto nahrazení jsme provedli kvùli zvolenému dìlení zásobníku u dna.

Po spuštìní algoritmu proces MASTER(id=0) naète zadání, provede nìkolik expanzí zásobníku a poté pošle všem ostatním procesùm jejich díl práce. Po pøijetí pøidìlené práce všechny procesy provádìjí sekvenèní prohledávání stavového prostoru(kadı své èásti).

Kadı proces mùe bıt ve stavu aktivní(neprázdnı zásobník), nebo neaktivní(prázdnı zásobník). 

Aktivní proces provádí vıpoèet a kadou 150. expanzi zkontroluje pøíchozí zprávy. Jak èasto provádìt kontrolu zpráv je nastaveno konstantou a je moné libovolnì mìnit. Pokud má proces ve frontì nìjaké pøíchozí zprávy, provádí jejich zpracování dokud není fronta prázdná. Pokud proces bìhem vıpoètu vyprázdní zásobník, pøejde do stavu neaktivní. 

Neaktivní proces vybere dárce a tomu pošle ádost o práci, pokud má u sebe peška, pošle ho následujícímu procesu ve smìru virtuální hamiltonovské krunice. Poté pouze obsluhuje pøípadné pøíchozí zprávy. Pøi pøíchodu kladné zprávy od dárce uloí poslanou práci na zásobník a pøechází do stavu aktivní, pøi záporné odpovìdi dárce vygeneruje nového dárce a ádost o práci opakuje.

Pro spuštìní algoritmu lze pouít stejnı pøíkaz jako pro spuštìní sekvenèní verze.

\subsection{Algoritmus hledání dárce}
Pro hledání dárce jsme zvolili algoritmus Náhodné vızvy (NV-AHD). Tento algoritmus pokadé, kdy se proces stane neèinnım vygeneruje náhodnì index dárce z mnoiny $\lbrace0,..., (p-1) \rbrace - \lbrace i \rbrace$, kde \textit{p} je poèet procesù a \textit{i} je index ádajícího procesu.

\subsection{Algoritmus dìlení zásobníku}
Zvolili jsme dìlení zásobníku u dna. U naší úlohy se dá pøedpokládat, e stavy u dna zásobníku pod sebou skrıvají více práce ne stavy vıše v zásobníku.

\subsection{Algoritmus pro distribuované ukonèení vıpoètu}
Pouili jsme modifikovanı Dijkstrùv peškovı algoritmus. Tento algoritmus je vhodnı pøi pouívání dynamického vyvaování zátìe.

\section{Teoretická efektivita algoritmu}
V nejhorším pøípadì prohledáme sekvenènì celı stavovı prostor. Velikost prostoru závisí na poètu vìí \textit{s} a na poètu tokenù \textit{n}. Proto pro sloitost sekvenèního øešení  platí:$$ SU(s,n)=O(s^{n})$$

Pro paralelní vıpoèet jsme se pokoušeli rozdìlit stavovı prostor rovnomìrnì mezi všechny procesory. Vıslednı paralelní èas je dán souètem doby vıpoètu na jednom procesoru$ T_{v} $ a komunikaèních nákladù $ T_{k} $. Paralelní èas lze tady vyjádøit následovnì: $$T(s,n,p) = T_{v} + T_{k} = O( \frac {s^{n}}{p} ) + T_{k}(s,n,p) $$

Pro cenu, zrychlení a efektivnost platí následující vztahy:
$$C(s,n,p) = p \times T(s,n,p) = p\times( \frac {s^{n}}{p} ) + T_{k}(s,n,p)=O(s^{n})+p\times T_{k}(s,n,p)  $$
$$S(s,n,p)= \frac{SU(s,n)}{T(s,n,p)} =\frac{O(s^{n})}{O( \frac {s^{n}}{p} ) + T_{k}(s,n,p)} = O(p)$$ U vısledné $S(s,n,p)$je zanedbána komunikaèní reie.
$$ E(s,n,p) = \frac{SU(s,n)}{C(s,n,p)}= \frac{O(s^{n})}{O(s^{n})+p\times T_{k}(s,n,p)}$$
Všechny uvedené vztahy pøedpokládají rovnomìrné rozdìlení práce.

Pro náš algoritmus jsme stanovili hranici, za kterou u se nevyplatí vıpoèet paralelizovat na 8. Pokud procesor má na dnì zásobníku stavy, kterım zbıvá ménì ne 8 krokù k dosaení maximální prohledávané hloubky, u se o tyto stavy s nikım nedìlí a vıpoèet dokonèí sám.

\section{Namìøené vısledky}
Mìøení jsme provedli tøikrát pro kadı vstup a danı poèet procesorù. Dále prezentované vısledky jsou prùmìrem tìchto tøech mìøení.

Mìøili jsme dobu bìhu paralelního algoritmu, poèet odeslanıch ádostí o práci a poèet odmítnutıch ádostí o práci.

Pouité vstupy:
\begin{itemize}
\item Input1.txt - Obsahuje 4 vìe, prohledávání probíhá do hloubky 20. Nejlepší øešení existuje v hloubce 18.
\item Input2.txt - Obsahuje 4 vìe, prohledávání probíhá do hloubky 23. Nejlepší øešení existuje v hloubce 17.
\item Input3.txt - Obsahuje 4 vìe, prohledávání probíhá do hloubky 22. Nejlepší øešení existuje v hloubce 15. 
\end{itemize}

\begin{figure}[h!]
\begin{center}  
    \includegraphics[height=125px]{Table1.png}
     \caption{Tabulka namìøenıch hodnot pro sí InfiniBand}
    \end{center}
\end{figure}

\begin{figure}
\begin{center}  
    \includegraphics[height=125px]{Table2.png}
     \caption{Tabulka namìøenıch hodnot pro sí Ethernet}
    \end{center}
\end{figure}

\begin{figure}
\begin{center}  
    \includegraphics[height=200px]{infinibandTime.png}
     \caption{Doba bìhu algoritmu na síti InfiniBand - èasová osa má logaritmické mìøítko}
    \end{center}
\end{figure}

\begin{figure}[h!]
\begin{center}  
    \includegraphics[height=200px]{ethernetTime.png}
     \caption{Doba bìhu algoritmu na síti Ethernet - èasová osa má logaritmické mìøítko}
    \end{center}
\end{figure}

\newpage
Jak je patrné z pøedchozích grafù, náš algoritmus bìí stejnì rychle na síti InfiniBand jako na síti Ethernet. Stejnou dobu bìhu si vysvìtlujeme tím, e naše aplikace komunikuje krátkımi zprávami($ \leq 1kb$). Dalším dùvodem je zvolené dìlení zásobníku u dna, kdy posílané stavy pod sebou skrıvají velké mnoství práce díky èemu neprobíhá komunikace nijak intenzivnì.


\begin{figure}
\begin{center}  
    \includegraphics[height=200px]{infinibandRequests.png}
     \caption{Poèty ádostí o práci a zamítnutıch ádostí o práci na síti InfiniBand}
    \end{center}
\end{figure}

\begin{figure}[h!]
\begin{center}  
    \includegraphics[height=200px]{ethernetRequests.png}
     \caption{Poèty ádostí o práci a zamítnutıch ádostí o práci na síti Ethernet}
    \end{center}
\end{figure}

\newpage
Vıše uvedené grafy zobrazující poèty ádostí o práci ukazují, e námi navrené komunikaèní schéma je velmi úèinné pro pro malé poèty procesorù. Pøi pouití nejvıše 8 procesorù pøesahuje úspìšnost ádostí o práci  90\% . Pøi zvyšujícím se poètu procesorù úspìšnost ádostí klesá a k  50\% . Do tohoto èísla se negativnì promítá doba tìsnì pøed koncem vıpoètu, kdy dochází práce a procesory se pokoušejí nìjakou získat. Dá se proto pøedpokládat, e bìhem vıpoètu mají ádosti o práci vyšší úspìšnost.

\begin{figure}[h!]
\begin{center}  
    \includegraphics[height=200px]{acceleration.png}
     \caption{Graf paralelního zrychlení pro jednotlivé vstupy.}
    \end{center}
\end{figure}


Z grafu zrychlení vyplıvá, e pro input1 a input3 dosáhl náš algoritmus superlineárního zrychlení. K superlineárnímu zrychlení došlo pravdìpodobnì protoe bylo vıraznì døíve nalezeno øešení v menší hloubce, ne byla hloubka prohledávaná. Tím došlo k omezení prohledávané hloubky a tedy i redukci poètu prohledávanıch stavù. Tomu odpovídá i velkı rozdíl v prohledávané hloubce a hloubce nalezeného øešení.





\section{Závìr}

Celkové zhodnocení semestrální práce a zkušenosti získanıch bìhem
semestru.

\section{Literatura}

\begin{itemize}
\item Prof. Ing. Pavel Tvrdík, CSc., Paralelní systémy a algoritmy, ÈVUT, Praha 2006
\item Doc. Jiroušek Radim, DrSc., Metody reprezentace a zpracování znalostí v umìlé inteligenci, VŠE, Praha 1995
\end{itemize}
\appendix



\end{document}
